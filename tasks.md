# Простые
**S01 (1б)** создать 4 переменных разного типа, продемонстрировать работу четырех арифметических операторов на выбор

**S02 (1б)** Покажите работу операторов деления нацело и определения остатка от деления

**S11 (1б)** Циклически перебрать числа от 0 до 100. Если число делится на 3 вывести его на экран:  `0	3	6	...	99`

**S12 (1б)** Используя другой тип цикла, перебрать числа от 1 до 1000 с шагом 4. Найти сумму всех чисел, которые делятся на 7 без остатка 
```
Sum: 17640  // (0 - 1000)
Sum: 17395  // (1 - 1000)
```
**S21 (1б)** Получить от пользователя два числа А, В (В>A). Пройти циклом от А до В, вывести значение каждого числа умноженного на 3 в файл «output»

**S22 (1б)** Используя цикл прочитать каждое число из файла «output» и вывести на экран в виде: «n. Число», где n - порядковый номер числа в файле


**S31 (1б)**  Создайте текстовый массив с названиями цифр от 0 до 9. Пользователь вводит число и получает на экран его название.

**S32 (1б)** Пользователь вводит строку. Используя указатель на строку, сдвиньте каждую букву в строке на 1 (a → b, b→c …) (каждый символ задается числом) длину строки можно получить функцией `strlen()` из библиотеки `cstring`.

**S41 (1б)** Напишите функцию `squared_sum()`, которая принимает два дробных числа и возвращает квадрат их суммы
```cpp
cout << squared_sum(12, 6) <<"\n"; // 324
cout << squared_sum(12, -6) <<"\n"; // 36
```

**S42 (2б)** Напишите функцию `sort()`, которая принимает массив из 10 чисел и сортирует их по убыванию
```cpp
int a[10] = {1, 8, 3, 6, 5, 4, 9, 2, 8, 12};
sort(a);	// 12 9 8 7 6 5 4 3 2 1
```

**S51 (1б)** Напишите функцию `reverse()`, которая принимает строку и выводит ее на экран в отраженном виде. «Testing» → «gnitseT»

**S52 (1б)** Напишите перегруженную функцию `print()`, которая выводит на отдельной строке значения, передаваемые ей через запятую. Функция может принимать: 1) `int`; (2) `float`; (3) `char`; (4) `int` и `int`; (Таким образом, фактически, нужно написать четыре функции)


**S61 (2б)** Написать класс ведра `Bucket`.
свойства: `volume` (объем в литрах) и `used` (сколько литров уже налито)
методы: `flush()` (опустошить. весь объем становится доступным для использования) и `fill(v)` (наполнить v литрами жидкости). При вызове метода `fill()` выполняется проверка - достаточно ли в ведре незанятого объема. Если достаточно - метод заполняет ведро (меняет свойство `used`) и возвращает 0. Если недостаточно - ведро заполняется настолько, насколько возможно и возвращается разница (тот объем, который не поместился)
```cpp
    // тестовый код
    Bucket test_01(12, 3);
    cout << "1) " << test_01.volume << ", " << test_01.used << "\n"; // 12, 3
    int rest = test_01.fill(14);
    cout << "2) " << test_01.used << ", " << rest << "\n";  // 12, 5
    
    test_01.flush();
    rest = test_01.fill(8);
    cout << "3) " << test_01.used << ", " << rest << "\n";   // 8, 0
```

**S71 (2б)** Напишите класс `CreditCard`. Его свойства: `Number` (`int`, номер из  4 цифр) и `Balance` (`float`, баланс карты); методы: `Put(V)` и `Take(V)` - положить и снять деньги. И то и другое задается при создании объекта: `CreditCard firstCC(1234, 50)` - карта с номером 1234 и балансом в 50 Р. Продемонстрируйте обращение к методу по указателю ( -> ).

**S72 (2б)** Напишите функцию `Transfer(C1, C2, V)`: где C1 и C2 - это экземпляры класса `CreditCard`; V - это сумма. Функция переводит сумму V с карты С1 на карту С2. Баланс карты С1 не может стать отрицательным. Если денег на карте С1 не хватает для перевода, выводится сообщение об ошибке. Если номера карт совпадают, выводится сообщение, что это одна и та же карта и операция не проводится.

**S81 (1б)** Перегрузите унарный оператор инкремента (`++`) для применения к текстовым строкам: его применение смещает все символы в строке на 1 (см. задание 4.2). Таким же образом перегрузите оператор декремента (`--`)

**S82 (1б)** Перегрузите бинарный оператор + для класса CreditCard так, чтобы операция С1 + С2 переносила весь баланс с С2 на С1 (добавляла все сумму с С2 к С1 и обнуляла баланс С2)


# Средние: 
**M01 (3б)** Используя циклы выведите таблицу Пифагора. Она должна быть отформатирована (используйте символ табуляции).

**М02 (4б)** Функция принимает два параметра: сторона А и число сторон N, и должна вернуть площадь N-угольника со стороной А. 

# Сложные (5-6): (уникальные 15 шт.)
**H01 (5б)** Напишите функцию расчета синуса, используя его представление в виде ряда: $$sin(x) = x - x^3/3! + x^5/5! - x^7/7! + x^9/9! - x^11/11! + x^13/13! + ... $$ 
Ограничьтесь первыми 10-ю членами ряда. Вычисление должно происходить в цикле. 
Рекомендация: используйте величины, вычисленные на предыдущем шаге.
Сравните результат вашей функции с тем, что дает sin из модуля `math.h`.

**H02 (5б)** Напишите класс комплексных чисел `Complex`. При объявлении переменной типа `Complex`, ему передаются действительная r и мнимая i части: `Complex v(4,5)`. Перегрузите операторы сложения, вычитания, умножения и деления согласно правил этих операций для комплексных чисел (см. комплексная арифметика). Продемонстрируйте работу всех операторов.
